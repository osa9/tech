# Programming language theory
* Programming language theory
* Abstract syntax
* Divergence (computer science)
* First-class function
* Function-level programming
* Higher-order abstract syntax
* Logic error
* Logic of Computable Functions
* Non-local variable
* POPLmark challenge
* Programming Computable Functions
* Proof-carrying code
* Qualification principle
* Referential transparency
* Semantic error
* Side effect (computer science)
* Structured program theorem
* Syntax error
* Turing completeness
* Typed assembly language
* Variadic
## Programming language researchers
* List of programming language researchers
* Frances E. Allen
* Andrew Appel
* Lennart Augustsson
* Marc Auslander
* John Backus
* David F. Bacon
* Henry Baker (computer scientist)
* Mordechai Ben-Ari
* Rudolf Berghammer
* Richard Bird (computer scientist)
* Per Brinch Hansen
* Jim Brown (computer scientist)
* Luca Cardelli
* Craig Chambers
* James Cordy
* Patrick Cousot
* Radhia Cousot
* Olivier Danvy
* Frederica Darema
* Edsger W. Dijkstra
* Christophe de Dinechin
* R. Kent Dybvig
* Andrey Ershov
* Richard Fateman
* Matthias Felleisen
* Wally Feurzeig
* Robert Bruce Findler
* Matthew Flatt
* Pat Fothergill
* Michael Franz
* Daniel P. Friedman
* Carlo Ghezzi
* Andrew D. Gordon
* Susan L. Graham
* Bernard Greenberg
* David Gries
* Charles Leonard Hamblin
* Robert Harper (computer scientist)
* Tony Hoare
* Paul Hudak
* John Hughes (computer scientist)
* Jean Ichbiah
* Gregor Kiczales
* Shriram Krishnamurthi
* Monica S. Lam
* Peter Landin
* John Launchbury
* Xavier Leroy
* Karl Lieberherr
* Barbara Liskov
* Peter Lucas (computer scientist)
* Harry Mairson
* Erik Meijer (computer scientist)
* Bertrand Meyer
* Robin Milner
* John C. Mitchell
* David A. Moon
* Roger Moore (computer scientist)
* Greg Morrisett
* Ike Nassi
* George Necula
* Greg Nelson (computer scientist)
* Oscar Nierstrasz
* Kristen Nygaard
* Martin Odersky
* Richard O'Keefe
* Simon Peyton Jones
* Frank Pfenning
* Benjamin C. Pierce
* Gordon Plotkin
* Amir Pnueli
* Thomas W. Reps
* John C. Reynolds
* Peter H. Salus
* Klaus Samelson
* David Sayre
* Gunther Schmidt
* John M. Scholes
* Dana Scott
* Michael Spivey
* George Springer (mathematician)
* Guy L. Steele Jr.
* Joe Stoy
* Christopher Strachey
* Don Syme
* Cynbe ru Taren
* Tim Teitelbaum
* David Turner (computer scientist)
* Philip Wadler
* John Wainwright (computer scientist)
* Mitchell Wand
* Peter Wegner
* Stephanie Weirich
* Richard Wexelblat
* Niklaus Wirth
* Stephen Wolfram
## Academic programming languages
* Absys
* Agda (programming language)
* ALF (proof assistant)
* ALGOL 60
* ALGOL 68
* Baby Modula-3
* Cayenne (programming language)
* CLU (programming language)
* Curry (programming language)
* Dafny
* Epigram (programming language)
* FL (programming language)
* FP (programming language)
* FX-87
* Haskell (programming language)
* Hope (programming language)
* ISWIM
* Joy (programming language)
* Lisp (programming language)
* Lucid (programming language)
* ML (programming language)
* NPL (programming language)
* OBJ (programming language)
* Orwell (programming language)
* P′′
* PAL (programming language)
* Parlog
* Pascal (programming language)
* Programming Computable Functions
* Racket (programming language)
* SASL (programming language)
* Scheme (programming language)
* SETL
* Turing (programming language)
* Whiley (programming language)
## Compiler construction
* Abstract syntax
* Affix grammar
* Aliasing (computing)
* Array access analysis
* Aspect weaver
* Attribute grammar
* Backus–Naur form
* Basic block
* Extended basic block
* Binary recompiler
* Bootstrapping (compilers)
* Call graph
* Code generation (compiler)
* Compile time
* Compile time function execution
* Compiler
* Compiler correctness
* Compiler Description Language
* Compiler-compiler
* Compilers: Principles, Techniques, and Tools
* Context-free grammar
* Control table
* Control-flow graph
* Data structure alignment
* Dead code
* Dominator (graph theory)
* Dynamic compilation
* Dynamic recompilation
* ECLR-attributed grammar
* Extended Backus–Naur form
* First-class function
* Funarg problem
* GNU cflow
* Intermediate representation
* Intrinsic function
* Just-in-time compilation
* L-attributed grammar
* Lambda lifting
* Lexical analysis
* Link time
* Literal pool
* LR-attributed grammar
* Man or boy test
* Manifest expression
* Memory model (programming)
* Memory ordering
* Metacompilation
* Name mangling
* Name resolution (programming languages)
* Normalized loop
* Object file
* Optimizing compiler
* Overhead code
* Parsing
* Principles of Compiler Design
* S-attributed grammar
* Semantic analysis (compilers)
* Semantic dictionary encoding
* Sethi–Ullman algorithm
* Standard Portable Intermediate Representation
* Static build
* String grammar
* Syntax-directed translation
* Three-address code
* Tombstone diagram
* Trace scheduling
* Trace tree
* Tracing just-in-time compilation
* Translation unit (programming)
* Translational Backus–Naur form
* Unparser
* Van Wijngaarden grammar
## Dependently typed programming
* Dependent type
* Dependently typed programming
* Brouwer–Heyting–Kolmogorov interpretation
* Calculus of constructions
* Curry–Howard correspondence
* Generalized algebraic data type
* Higher-order abstract syntax
* Inductive data type
* Intuitionistic type theory
* Logical framework
* Proof-carrying code
* Type variable
## Lambda calculus
* Lambda calculus
* Anonymous function
* Applicative computing systems
* Apply
* B, C, K, W system
* Beta normal form
* Böhm tree
* Calculus of constructions
* Call-by-push-value
* Cartesian closed category
* Church encoding
* Church–Rosser theorem
* Combinatory logic
* Context change potential
* Currying
* De Bruijn index
* De Bruijn notation
* Deductive lambda calculus
* Director string
* Divergence (computer science)
* Explicit substitution
* Fixed-point combinator
* Higher-order function
* Hindley–Milner type system
* Intersection type discipline
* Kleene–Rosser paradox
* Knights of the Lambda Calculus
* Krivine machine
* Lambda calculus definition
* Lambda cube
* Lambda lifting
* Lambda-mu calculus
* Let expression
* Mogensen–Scott encoding
* Montague grammar
* Normalisation by evaluation
* Normalization property (abstract rewriting)
* Pattern calculus
* Pure type system
* Reduction strategy (lambda calculus)
* Rho calculus
* Scott–Curry theorem
* Simply typed lambda calculus
* SKI combinator calculus
* Supercombinator
* System F
* System F-sub
* System U
* Type inhabitation
* Typed lambda calculus
* Untyped lambda calculus
* Η-conversion
## Program analysis
* Program analysis
* Abstract interpretation
* Aliasing (computing)
* Compiler-compiler
* Dynamic program analysis
* Effect system
* Flow-sensitive typing
* KPI-driven code analysis
* Perl::Critic
* Polyvariance
* Program slicing
* Reaching definition
* Search-based software engineering
* Semantic analysis (compilers)
* Static program analysis
* Steensgaard's algorithm
* Type rule
* Type system
* Typestate analysis
* Typing environment
* Use-define chain
## Program transformation
* Program transformation
* C to HDL
* Code Morphing Software
* List of program transformation systems
* Operation Reduction for Low Power
* Program slicing
* SrcML
* Tombstone diagram
## Programming languages
* Programming language
* Аналитик
* ActionScript
* Ada (programming language)
* Address programming language
* Agda (programming language)
* ALGOL 68
* Apache Groovy
* APL (programming language)
* AppleScript
* AspectJ
* Auto-lead Data Format
* BASIC
* Behavioral Description Language
* BLISS
* Boo (programming language)
* Boomerang (programming language)
* Bosque (programming language)
* Bs (programming language)
* Cameleon (programming language)
* C Sharp (programming language)
* C++17
* Caml
* Cedar (programming language)
* Céu (programming language)
* Charm (programming language)
* Chef (programming language)
* Clascal
* Clipper (programming language)
* Clojure
* Computer language
* Concordion
* COWSEL
* Cuneiform (programming language)
* Cybil (programming language)
* D (programming language)
* DARSIMCO
* Darwin (programming language)
* Deductive language
* DIBOL
* E (programming language)
* Эль-76
* Elixir (programming language)
* Embedded style language
* Erlang (programming language)
* EXAPT
* Factor (programming language)
* Flow chart language
* Flowcode
* Forth (programming language)
* FreeBASIC
* FX-87
* General-purpose programming language
* GEORGE (programming language)
* GLOBAL
* Go (programming language)
* Golo (programming language)
* GOLOG
* Gosu (programming language)
* Haggis (programming language)
* Haxe
* Hermes (programming language)
* Io (programming language)
* Janus (time-reversible computing programming language)
* Java (programming language)
* Java technology
* Join Java
* Jolie (programming language)
* Joy (programming language)
* JS++
* Julia (programming language)
* K (programming language)
* Kinetic Rule Language
* Kojo (learning environment)
* KOMPILER
* Kotlin (programming language)
* Language interoperability
* LFE (programming language)
* LINGO (mathematical modeling language)
* Lisp (programming language)
* Little b (programming language)
* LiveCode
* Lua (programming language)
* MATH-MATIC
* Mercury (programming language)
* Milk (programming language)
* MiniKanren
* Mocklisp
* Multi-adjoint logic programming
* Nemerle
* Nim (programming language)
* OpenQASM
* P (programming language)
* Petit Computer
* PHP
* Pico (programming language)
* PL/M
* POP-2
* Processing (programming language)
* Programming Languages: Application and Interpretation
* PureBasic
* PV-Wave
* Python (programming language)
* Q Sharp
* Qore (programming language)
* Quantum Computation Language
* Raku (programming language)
* Real-time Programming Language
* Rebol
* S-PLUS
* Scala (programming language)
* Scientific Vector Language
* Scriptol
* Self (programming language)
* Sibernetic
* Simula
* SLIP (programming language)
* Smalltalk
* Smart Pascal
* SMX (computer language)
* SNOBOL
* Source (programming language)
* Squeak
* Squirrel (programming language)
* Structured text
* Swift (parallel scripting language)
* Swift (programming language)
* Synergy DBL
* Tea (programming language)
* ThinBasic
* TI-BASIC 83
* Tritium (programming language)
* TTCN-3
* Universal Test Specification Language
* Vala (programming language)
* Visual Basic
* Visual FoxPro
* XL (programming language)
* XPL
## Rewriting systems
* Abstract rewriting system
* Buchberger's algorithm
* Canonical rewriting system
* Church–Rosser theorem
* Confluence (abstract rewriting)
* Congruence closure
* Convergence (logic)
* Critical pair (logic)
* Dershowitz–Manna ordering
* Director string
* Divergence (computer science)
* Encompassment ordering
* Explicit substitution
* Gröbner basis
* Jean-Pierre Jouannaud
* Knuth–Bendix completion algorithm
* Markov algorithm
* Newman's lemma
* Normal form (abstract rewriting)
* Orthogonality (term rewriting)
* Overlap (term rewriting)
* Path ordering (term rewriting)
* Reduction (abstract rewriting)
* Reduction ordering
* Reduction strategy (code optimization)
* Reflexive closure
* Rewrite order
* Rewriting
* Semi-Thue system
* Symmetric closure
* Term (logic)
* Termination (term rewriting)
* Unification (computer science)
* Word problem (mathematics)
## Programming language semantics
* Semantics (computer science)
* Action semantics
* Algebraic semantics (computer science)
* Axiomatic semantics
* Call-by-push-value
* Denotational semantics
* Dynamic semantics
* Execution semantics
* Full abstraction
* J operator
* Liskov substitution principle
* Logical relations
* Natural semantics
* Normalisation by evaluation
* Observational equivalence
* Operational semantics
* Reduction strategy (lambda calculus)
* Unifying Theories of Programming
## Substitution (logic)
* Substitution (logic)
* Capture-avoiding substitution
* Explicit substitution
## Type theory
* Abstract data type
* Abstract type
* Ad hoc polymorphism
* Algebraic data type
* Attribute domain
* Automath
* Axiom of reducibility
* Bottom type
* Bounded quantification
* Calculus of constructions
* Categorial grammar
* Combinatory categorial grammar
* Composite data type
* Container (type theory)
* Covariance and contravariance (computer science)
* Curry–Howard correspondence
* Dependent type
* Derived type
* Duck typing
* Effect system
* Empty type
* Enumerated type
* Existential type
* Extensional type theory
* Flow-sensitive typing
* Function type
* Functor (type theory)
* Generalized algebraic data type
* Girard's paradox
* Higher-order abstract syntax
* Hindley–Milner type system
* History of type theory
* Homotopy type theory
* Identity type
* Induction-induction
* Induction-recursion
* Inductive data type
* Inductive type
* Initial algebra
* Intensional type theory
* Intersection type
* Intersection type discipline
* Intuitionistic type theory
* Kind (type theory)
* Lambda cube
* Liskov substitution principle
* Logical framework
* Mathematical structure
* New Foundations
* Nominative and structural type systems
* Nullable type
* Open–closed principle
* Option type
* Ordered pair
* Parametric polymorphism
* Parametricity
* Polymorphism (computer science)
* Polynomial functor (type theory)
* Pregroup grammar
* Principal type
* Product type
* Prototype-based programming
* Pure type system
* Quotient type
* Ramified theory of types
* Rank (type theory)
* Recursive data type
* Refinement type
* Setoid
* Simply typed lambda calculus
* ST type theory
* Static cast
* Stream (computer science)
* Subject expansion
* Subject reduction
* Substructural type system
* Subtyping
* System F
* System F-sub
* System U
* Tagged union
* Top type
* Trait (computer programming)
* Tuple
* Twelf
* Typability
* Type checking
* Type class
* Type constructor
* Type conversion
* Type erasure
* Type family
* Type inference
* Type inhabitation
* Type reconstruction
* Type rule
* Type safety
* Type signature
* Type system
* Type theory
* Type theory with records
* Type variable
* Typed lambda calculus
* Typing environment
* Unification (computer science)
* Uniqueness type
* Unit type
* Universal type
* Universal types
* Value (computer science)
* Variable (computer science)
* Void type
## Programming language theory stubs
* Algebraic semantics (computer science)
* Container (type theory)
* Convergence (logic)
* Efferent coupling
* Fluent (artificial intelligence)
* Jump threading
* Latent typing
* Orthogonality (term rewriting)
* Principal type
* Refinement type
* Reflexive closure
* Stream (computer science)
* Subject reduction
* Syntactic closure
* System F-sub
* Type inhabitation
* Type rule
* Type variable
* Typing environment
* Value restriction
